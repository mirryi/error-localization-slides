% \begin{frame}{}
  % \begin{columns}
    % \begin{column}{0.5\linewidth}
      % \begin{itemize}
        % \item 
      % \end{itemize}
    % \end{column}
    % \begin{column}{0.5\linewidth}
      % \begin{itemize}
        % \item 
      % \end{itemize}
    % \end{column}
  % \end{columns}
% \end{frame}

\begin{frame}[fragile]{Familiar sights}
  A
\end{frame}

\begin{frame}{Nowadays\ldots}
  \begin{itemize}
    \item We program with high-level abstractions \\ \pause
      but these abstractions can be complex!

      \pause
    \item We rely on help from our editors \\ \pause
      which provide \emph{rich semantic services}!

      \pause
    \item We write a lot of ill-formed code \\ \pause
      so services must be error-resilient!
  \end{itemize}
\end{frame}

% \begin{frame}[fragile]{Localization is varied}
  % \[%
    % \ELet{x}{\EIf{\ETrue}{\ENum{5}}{}}{\cdots}
  % \]%

    % \begin{semiverbatim}\small
% 1 | let x = if true then 5 else false
                                % \textcolor{red}{^^^^^}
% \textcolor{red}{\textbf{Error}}: This expression has type bool but an expression
         % was expected of type int
% \pause
% Main.hs:1:18: \textbf{\textcolor{red}{error}:} \textbf{[\textcolor{red}{GHC-39999}]}
    % • No instance for ‘Num Bool’ arising from the literal ‘5’
    % • In the expression: 5
      % In the expression: if True then 5 else False
      % In an equation for ‘x’: x = if True then 5 else False
  % |
% 1 | x = if True then \textcolor{red}{\textbf{5}} else False
  % |                  \textcolor{red}{\textbf{^}}
    % \end{semiverbatim}

% main.cpp: In function ‘auto f()’:
% main.cpp:5:12: error: inconsistent deduction for auto return type: ‘int’ and then ‘bool’
%     5 |     return false;
%       |            ^~~~~

% error[E0308]: `if` and `else` have incompatible types
 % --> src/main.rs:2:34
  % |
% 2 |     let x = if true { 5 } else { false };
  % |                       -          ^^^^^ expected integer, found `bool`
  % |                       |
  % |                       expected because of this
% \end{frame}

\begin{frame}{A definitional gap problem}
  \begin{center}
    Most of the code we write is \emph{ill-formed}\pause,
    but conventional language definitions
    \emph{only specify the behaviour of well-formed programs}.
  \end{center}
  \pause
  \[%
    \bm{\Downarrow}
  \]%

  \begin{center}
    If a type error appears \textcolor{RedOrange}{\textbf{anywhere}},\\
    the program is meaningless \textcolor{Red}{\textbf{everywhere}}.
  \end{center}
\end{frame}

\begin{frame}{The goal}
  We'd like to be able to \emph{formally} specify type checkers that \\[0.5em]

  \pause
  \begin{enumerate}
    \item describe where and what the errors are \pause (\emph{localization})
    
      \pause
    \item carry on in spite of them \pause (\emph{recovery})
  \end{enumerate}

  \vspace{1em}
  \pause
  \begin{mainbox}[]{Guiding principle\only<8->{ (totality)}}
    \pause
    These typing semantics should describe \\
    \emph{all syntactically well-formed programs}.
  \end{mainbox}
\end{frame}

\begin{frame}{This paper is about\ldots}
  \begin{itemize}
    \item<1-> the \textbf{marked lambda calculus}%
      \uncover<2->{%
        : a judgmental framework for \onderline<3->{total} \onderline<4->{bidirectional}
        type error localization and recovery%
      }

    \item<4-> \textbf{type hole inference}%
      \uncover<5->{%
        , a global, constraint-based system \\ \pause
        that is \emph{gradual} and \emph{neutral} in error localization and recovery
      }
  \end{itemize}
\end{frame}
