\begin{frame}{Marking \underline{global} inconsistencies}
  Consider this program:
  \[%
    \ELam{f}{\TUnknown}{\EAp{f}{(\EPlus{f}{1})}}
  \]%

  \pause
  $\assignType{f}{\TUnknown}$, so the bidirectional system operates gradually, \pause
  but $f$ is 
  %
  \pause
  \begin{enumerate}
    \item applied as a function \pause (a function?)
      \pause
    \item an operand of $\ECOpPlus$ \pause (a number?)
  \end{enumerate}

  \pause
  \vspace{1em}
  \emph{Global, constraint-based type checking would have caught this!}
\end{frame}

\begin{frame}{Layers upon layers}
  Get the best of both worlds by layering \textbf{constraint-based inference} 
  atop the marked lambda calculus

  \vspace{1em}
  \pause
  \begin{itemize}
    \item The marked lambda calculus localizes and recovers predictably from \emph{local inconsistencies}

      \pause
    \item \textbf{Type hole inference} solves and marks \emph{global inconsistencies}
  \end{itemize}
\end{frame}

\begin{frame}{Type hole inference}
  \begin{itemize}
    \item Occurrences of $\TUnknown$ arise from
      \pause (1) \emph{type holes}, \eg, in $\ELam{x}{\TUnknown}{\cdots}$
      \pause or (2) error marks

      \pause
    \item Gather constraints from the bidirectional systems\pause,
      treating occurrences of $\TUnknown$ as unification variables
      {\footnotesize\parencite{siek2008}}

      \pause
    \item Solve them via a standard unification algorithm {\footnotesize\parencite{huet1976}} \\
      \pause whilst \emph{accumulating the potential types for each variable} \\
      \pause and \emph{continuing on in the face of failures}
  \end{itemize}
\end{frame}

\newcommand{\Id}[1]{\ensuremath{\goodcolor{hole}{#1}}}
\newcommand{\IdU}{\ensuremath{\Id{u}}}
\newcommand{\ProvU}{\ensuremath{\IdU}}
\newcommand{\ProvExp}[1]{\ensuremath{exp\goodcolor{\colorOkSideJudge}{(}#1\goodcolor{\colorOkSideJudge}{)}}}
\newcommand{\ProvIn}[1]{\ensuremath{\to_L\goodcolor{\colorOkSideJudge}{(}#1\goodcolor{\colorOkSideJudge}{)}}}
\newcommand{\ProvOut}[1]{\ensuremath{\to_R\goodcolor{\colorOkSideJudge}{(}#1\goodcolor{\colorOkSideJudge}{)}}}

\begin{frame}{Provenances for types}
  Add type provenances $\Provp$ to the \emph{marked language}:

  \vspace{1em}
  \pause
  \begin{itemize}
    \item Link occurrences of $\TUnknown$ to the originating type hole or error mark
      (denoted by unique id $\IdU$)

    \item Distinguish between different $\TUnknown$ based on locus
  \end{itemize}

  \pause
  \[\begin{array}{rcl}
    \Provp & \Coloneqq & \ProvU \mid \ProvExp{\ProvU} \mid \ProvIn{\Provp} \mid \ProvOut{\Provp} \\
    \pause
    \TMV   & \Coloneqq & \cdots \mid \TUnknown^{p}\\
    \pause
    \ECMV  & \Coloneqq & \cdots \mid \ECFreeId{x}{\IdU} \mid \ECApSynNonMatchedArrowId{\ECMV}{\IdU} \mid \ECInconTypeId{\ECMV}{\IdU}
  \end{array}\]
\end{frame}

\begin{frame}{Generating constraints bidirectionally}
  Augment the type system (of the marked language) to generate sets $C$ of constraints
  $\constrain{\TMV_1}{\TMV_2}$\pause, which force $\TMV_1$ and $\TMV_2$ to be consistent:
  \pause
  \[%
    \synConstraint{\ctx}{\ECMV}{\TMV}{C} \qquad \anaConstraint{\ctx}{\ECMV}{\TMV}{C}
  \]%

  \pause
  \begin{mathpar}
    \judgment{
      \synConstraint{\ctx}{\ECMV}{\TMV'}{C} \\
      \consistent{\TMV}{\TMV'}
    }{
      \anaConstraint{\ctx}{\ECMV}{\TMV}{C \cup \{ \constrain{\TMV}{\TMV'} \}}
    }{MASubsume-C}

    \pause
    \judgment{
        \synConstraint{\ctx}{\ECMV}{\TMV'}{C} \\
        \inconsistent{\TMV}{\TMV'}
    }{
      \anaConstraint{\ctx}{\ECInconTypeId{\ECMV}{u}}{\TMV}{C \cup \{ \constrain{\TMV}{\TUnknown^{\ProvExp{\IdU}}} \}}
    }{MAInconsistentTypes-C}
  \end{mathpar}
\end{frame}

\begin{frame}{Unification with inconsistencies}
  For each occurrence of $\TUnknown$, accumulate the $\mathsf{PotentialTypeSet}$\pause: \\
  \emph{all} potential type fillings as inferred from the constraints

  \[\begin{array}{rrcl}
    \mathsf{PotentialTypeSet} & s & \Coloneqq & \{ t^{*} \} \\
    \mathsf{PotentialType}    & t & \Coloneqq & \TUnknown^\Provp \mid \TNum \mid \TBool \mid \TArrow{s}{s}
  \end{array}\]

  \vspace{1em}
  \pause
  To unify $\constrain{\TMV_1}{\TMV_2}$, recursively merge $\mathsf{PotentialTypeSet(\TMV_1)}$
  and $\mathsf{PotentialTypeSet(\TMV_2)}$.
\end{frame}

\newcommand{\PTS}{\operatorname{\mathsf{PotentialTypeSet}}}
\newcommand{\cursor}{\ensuremath{\goodcolor{\colorOkSideJudge}{\bm{\wedge}}}}

\begin{frame}
  \[%
    \ELam{f}{\TUnknown^{\Id{1}}}{\EAp{f}}{(\EPlus{f}{1})}
  \]%

  \uncover<2->{
    yields the (inconsistent) constraints
    \[%
      \{ \onderset<6>{\cursor}{\constrain{\TUnknown^{\Id{1}}}{\TArrow{\TUnknown^{\ProvIn{\Id{1}}}}{\TUnknown^{\ProvOut{\Id{1}}}}}}
       \only<3->{, \onderset<7>{\cursor}{\constrain{\TNum}{\TUnknown^{\Id{1}}}}}
       \only<4->{, \onderset<8>{\cursor}{\constrain{\TNum}{\TUnknown^{\ProvIn{\Id{1}}}}}} \}
    \]%
  }
  
  \vspace{-1em}
  \uncover<5->{
    and solving gives
    \[%
      \PTS(\TUnknown^{\Id{1}})
        =
      \Alt<6->{
        \Alt<7->{
          \Alt<8->{
            \{ \TArrow{\{ \onderline<8>{\TNum} \}}{\{ \TUnknown^{\ProvOut{\Id{1}}} \}},
               \TNum \}
          }{
            \{ \TArrow{\{ \TUnknown^{\ProvIn{\Id{1}}} \}}{\{ \TUnknown^{\ProvOut{\Id{1}}} \}},
             \underline{\TNum} \}
          }
        }{
          \{ \underline{\TArrow{\{ \TUnknown^{\ProvIn{\Id{1}}} \}}{\{ \TUnknown^{\ProvOut{\Id{1}}} \}}} \}
        }
      }{
        \{ \}
      }
    \]%
  }
\end{frame}

\begin{frame}
  \[%
    \ELam{f}{\TUnknown^{\Id{1}}}{\EAp{f}}{(\EPlus{f}{1})}
  \]%
  \[%
    \PTS(\TUnknown^{\Id{1}})
      = \{ \TArrow{\{ \TNum \}}{\{ \TUnknown^{\ProvOut{\Id{1}}} \}},
         \TNum \}
  \]%

  \vspace{1em}
  We know:

  \vspace{1em}
  \pause
  \begin{itemize}
    \item Two potential fillings of $\TUnknown^{\Id{1}}$ are $\TArrow{\TNum}{\TUnknown}$ and $\TNum$\pause, \\
      which is more than one!

      \pause
    \item $\TUnknown^{\Id{1}}$ is unsolved; inconsistent constraints!
  \end{itemize}
\end{frame}

\begin{frame}{Neutral by construction}

\end{frame}
