\begin{frame}{Marking global inconsistencies?}
  Consider this program:
  \[%
    \ELam{f}{\TUnknown}{\EAp{f}{(\EPlus{f}{1})}}
  \]%

  \pause
  $\assignType{f}{\TUnknown}$, so the bidirectional system operates gradually, \pause
  but $f$ is 
  %
  \pause
  \begin{enumerate}
    \item applied as a function \textcolor{Black!50}{(a function?)}
      \pause
    \item an operand of $\ECOpPlus$ \textcolor{Black!50}{(a number?)}
  \end{enumerate}

  \pause
  \vspace{1em}
  \emph{Global, constraint-based type checking would have caught this!}

  \note[item]{Since the marked lambda calculus is for bidirectional systems, it might not do
    everything we'd like}
  \note[item]{In this program, the type of f is given to be unknown, so the bidirectional system
    would operate gradually and results in no marks}
  \note[item]{But we notice that it's used a function and a number simultaneously, which isn't
    possible}
  \note[item]{In other ways, there's no way to replace the unknown type, or type hole as well we
    call them, with a known type}
  \note[item]{And anyway we think, well, some sort of global, constraint-based inference system
    would have caught this!}
\end{frame}

\begin{frame}{Layers upon layers}
  Get the best of both worlds by layering \textbf{constraint-based inference} 
  atop the marked lambda calculus \\[1em]

  \pause
  \begin{itemize}
    \item The marked lambda calculus localizes and recovers predictably from \emph{local inconsistencies}

      \pause
    \item \textbf{Type hole inference} solves and marks \emph{global inconsistencies} 

      \pause
      \begin{itemize}
        \item Downstream service to supplement the marked lambda calculus
      \end{itemize}
  \end{itemize}

  \note[item]{In the second part of this paper, we describe how we can the best of both worlds by
    layering a constraint-based inference system atop the marked lambda calculus}
  \note[item]{Where the latter provides local inference with error localization and recovery}
  \note[item]{And type hole inference operates on the marked terms to solve and mark
    global inconsistencies like the one in the example}
  \note[item]{Rather than being a standalone type checker, this is meant to be a downstream service
    to supplement the marked lambda calculus}
\end{frame}

\newcommand{\Id}[1]{\ensuremath{\goodcolor{hole}{#1}}}
\newcommand{\IdU}{\ensuremath{\Id{u}}}
\newcommand{\ProvU}{\ensuremath{\IdU}}
\newcommand{\ProvExp}[1]{\ensuremath{exp\goodcolor{\colorOkSideJudge}{(}#1\goodcolor{\colorOkSideJudge}{)}}}
\newcommand{\ProvIn}[1]{\ensuremath{\to_L\goodcolor{\colorOkSideJudge}{(}#1\goodcolor{\colorOkSideJudge}{)}}}
\newcommand{\ProvOut}[1]{\ensuremath{\to_R\goodcolor{\colorOkSideJudge}{(}#1\goodcolor{\colorOkSideJudge}{)}}}
\newcommand{\PTS}{\operatorname{\mathsf{PotentialTypeSet}}}
\newcommand{\cursor}{\ensuremath{\goodcolor{\colorOkSideJudge}{\bm{\wedge}}}}

\begin{frame}[fragile, t]{Type hole inference in Hazel}
  \begin{center}
    \alt<2->{
      \alt<3->{
        \includegraphics[width=0.9\textwidth]{inference-arrow.png}
      }{
        \includegraphics[width=0.9\textwidth]{inference-int.png}
      }
    }{
      \includegraphics[width=0.9\textwidth]{inference.png}
    }
    \vspace{2em}
    \alt<2->{
      \alt<3->{
        \includegraphics[width=0.9\textwidth]{inspector-arrow.png}
      }{
        \includegraphics[width=0.9\textwidth]{inspector-int.png}
      }
    }{
      \includegraphics[width=0.9\textwidth]{inspector.png}
    }
  \end{center}

  \begin{center}
    Try it out at \\
    \textcolor{MidnightBlue}{[\url{https://hazel.org/build/thi}]}
  \end{center}

  \begin{tikzpicture}[remember picture,overlay]
    \node[xshift=-4.6cm, yshift=-4.7cm, visible on=<2>] at (current page.north east) { \mousePointer };
    \node[xshift=-2.3cm, yshift=-4.7cm, visible on=<3>] at (current page.north east) { \mousePointer };
  \end{tikzpicture}

  \note[item]{Without getting into the weeds of how exactly it all works, let's take the
    previous example into Hazel with type hole inference}
  \note[item]{When unification is able to solve the constraints, things proceed as normal to find
    the appropriate substitution}
  \note[item]{However, like here, when unsolvable, the system degrades gracefully to maintain
    partial solutions by accumulating the possible type fillings}
  \note[item]{Notice that the system has marked the unknown type, the type hole here as unsolvable}
  \note[item]{and the cursor inspector tells us that the constraints demand f be both an int and int
    -> unknown}
  \note[item]{Instead of failing, type hole inference offers both possible fillings to the user, and
    if we hover over each, we can preview and then click to select the one we want}
  \note[item]{and by hovering over them, the code updates to show what would happen if we chose each
    one}
  \note[item]{When we hover over Int, it fills Int into the type hole, and now the application of f
    is marked with an error because control has, in some sense, been returned to the bidirectional
    system}
  \note[item]{Similarly, hovering over Int -> ? results in the second f being marked with an error}
\end{frame}

\begin{frame}
  This approach is \emph{neutral} \\[1em]

  \pause
  \begin{itemize}
    \item Localize errors to the originating type hole or error mark, \\
      instead of guessing about user intent

      \pause
    \item All potential type hole fillings are provided to the user for selection

      \pause
    \item Control returned to bidirectional system after user selects
  \end{itemize}

  \note[item]{This approach is neutral in the sense that we don't try to guess about user intent but
    simply provide all potential type hole fillings to the user for selection}
  \note[item]{facilitating a workflow of filling in type holes and returning control to the marked
    lambda calculus}
\end{frame}
